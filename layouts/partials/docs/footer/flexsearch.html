<script type="module">
    var suggestions = document.getElementById('suggestions');
    var search = document.getElementById('flexsearch');

    const flexsearchOverlay = document.getElementById('FlexSearchCollapse');
    const flexsearchContainer = document.getElementById('FlexSearchContainer');

    const hideFlexsearchBtn = document.getElementById('hideFlexsearch');

    const configObject = { toggle: false }
    const overlayCollapse = new Collapse(flexsearchOverlay, configObject);
    const containerCollapse = new Collapse(flexsearchContainer, configObject);

    // Helper function to show both overlay and search
    function showSearch() {
        overlayCollapse.show();
        containerCollapse.show();
        document.body.classList.add('search-overlay-active');
        // Add expanded class to both containers
        document.querySelector('.flexsearch-container').classList.add('search-expanded');
        document.querySelector('.flexsearch').classList.add('search-expanded');
        // Prevent body scroll when search is active
        document.body.style.overflow = 'hidden';
        setTimeout(() => search.focus(), 100);
    }

    // Helper function to hide both overlay and search
    function hideSearch() {
        overlayCollapse.hide();
        containerCollapse.hide();
        document.body.classList.remove('search-overlay-active');
        // Remove expanded class from both containers
        document.querySelector('.flexsearch-container').classList.remove('search-expanded');
        document.querySelector('.flexsearch').classList.remove('search-expanded');
        // Restore body scroll
        document.body.style.overflow = '';
        // Clear search input and suggestions
        search.value = '';
        suggestions.innerHTML = '';
        suggestions.classList.add('d-none');
    }

    // Make toggle function available globally for the search button
    window.toggleFlexSearch = function() {
        if (flexsearchContainer.classList.contains('show')) {
            hideSearch();
        } else {
            showSearch();
        }
    };

    if (search !== null) {
        document.addEventListener('keydown', inputFocus);
        
        // Click on overlay to close
        flexsearchOverlay.addEventListener('click', function(event) {
            hideSearch();
        });
    }

    hideFlexsearchBtn.addEventListener('click', () => {
        hideSearch();
    })

    // Prevent scroll propagation from suggestions to body
    if (suggestions !== null) {
        suggestions.addEventListener('wheel', function(e) {
            const scrollTop = suggestions.scrollTop;
            const scrollHeight = suggestions.scrollHeight;
            const height = suggestions.clientHeight;
            const delta = e.deltaY;
            const up = delta < 0;

            // Prevent scrolling beyond the bounds
            if (!up && delta > scrollHeight - height - scrollTop) {
                suggestions.scrollTop = scrollHeight;
                e.preventDefault();
            } else if (up && -delta > scrollTop) {
                suggestions.scrollTop = 0;
                e.preventDefault();
            }
        }, { passive: false });
    }

    function inputFocus(e) {
        if (e.ctrlKey && e.key === '/') {
            e.preventDefault();
            if (flexsearchContainer.classList.contains('show')) {
                hideSearch();
            } else {
                showSearch();
            }
        }
        if (e.key === 'Escape' ) {
            search.blur();
            suggestions.classList.add('d-none');
            hideSearch();
        }
    };

    document.addEventListener('click', function(event) {

    var isClickInsideElement = suggestions.contains(event.target);

    if (!isClickInsideElement) {
        suggestions.classList.add('d-none');
    }

    });

    /*
    Source:
    - https://dev.to/shubhamprakash/trap-focus-using-javascript-6a3
    */

    document.addEventListener('keydown',suggestionFocus);

    function suggestionFocus(e) {
    const suggestionsHidden = suggestions.classList.contains('d-none');
    if (suggestionsHidden) return;

    const focusableSuggestions= [...suggestions.querySelectorAll('a')];
    if (focusableSuggestions.length === 0) return;

    const index = focusableSuggestions.indexOf(document.activeElement);

    if (e.key === "ArrowUp") {
        e.preventDefault();
        const nextIndex = index > 0 ? index - 1 : 0;
        focusableSuggestions[nextIndex].focus();
    }
    else if (e.key === "ArrowDown") {
        e.preventDefault();
        const nextIndex= index + 1 < focusableSuggestions.length ? index + 1 : index;
        focusableSuggestions[nextIndex].focus();
    }

    }

    /*
    Source:
    - https://github.com/nextapps-de/flexsearch#index-documents-field-search
    - https://raw.githack.com/nextapps-de/flexsearch/master/demo/autocomplete.html
    */

    (function(){

    var index = new FlexSearch.Document({
        // charset: "latin:default",
        tokenize: {{ .Site.Params.flexsearch.tokenize | default "forward" }},
        minlength: {{ .Site.Params.flexsearch.minQueryChar | default 0}},
        cache: {{ .Site.Params.flexsearch.cache | default 100 }},
        optimize: {{ .Site.Params.flexsearch.optimize | default true }},
        document: {
        id: 'id',
        store: [
            "href", "title", "description"
        ],
        index: ["title", "description", "content"]
        }
    });


    // Not yet supported: https://github.com/nextapps-de/flexsearch#complex-documents


    // var docs = [
    //     {{ range $index, $page := (where .Site.Pages "Section" "docs") -}}
    //     {
    //         id: {{ $index }},
    //         href: {{ .Permalink }},
    //         title: {{ .Title }},
    //         description: {{ .Params.description }},
    //         content: {{ .Content }}
    //     },
    //     {{ end -}}
    // ];


    // https://discourse.gohugo.io/t/range-length-or-last-element/3803/2

    {{ $list := slice }}
    {{- if and (isset .Site.Params.flexsearch "searchsectionsindex") (not (eq (len .Site.Params.flexsearch.searchSectionsIndex) 0)) }}
        {{- if eq .Site.Params.flexsearch.searchSectionsIndex "ALL" }}
            {{- $list = .Site.Pages }}
        {{- else }}
            {{- $list = (where .Site.Pages "Type" "in" .Site.Params.flexsearch.searchSectionsIndex) }}
        {{- if (in .Site.Params.flexsearch.searchSectionsIndex "HomePage") }}
            {{ $list = $list | append .Site.Home }}
        {{- end }}
        {{- end }}
    {{- else }}
        {{- $list = (where .Site.Pages "Section" ($.Scratch.Get "pathName")) }}
    {{- end }}

    {{ $len := (len $list) -}}

    {{ range $index, $element := $list -}}
        index.add(
            {
                id: {{ $index }},
                href: "{{ .RelPermalink }}",
                title: {{ .Title }},
                {{ with .Description -}}
                    description: {{ . }},
                {{ else -}}
                description: {{ .Summary | htmlUnescape | plainify }},
                {{ end -}}
                content: {{ .Content | htmlUnescape | plainify }}
            }
        );
    {{ end -}}

    // Generate breadcrumb path from URL
    function generateBreadcrumb(href, pageTitle) {
        // Remove trailing slash and split the path
        const path = href.replace(/\/$/, '').split('/').filter(segment => segment);
        
        // Filter out language codes (en, es, etc.) and 'docs' from breadcrumb
        const filteredPath = path.filter(segment => 
            segment.length > 2 && segment !== 'docs'
        );
        
        // Convert path segments to readable names
        const breadcrumbSegments = filteredPath.map(segment => {
            // Replace hyphens and underscores with spaces
            let formatted = segment.replace(/[-_]/g, ' ');
            // Capitalize first letter of each word
            formatted = formatted.split(' ')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
            return formatted;
        });
        
        // If we have segments, use them; otherwise just use the page title
        if (breadcrumbSegments.length > 1) {
            // Replace the last segment with the actual page title
            breadcrumbSegments[breadcrumbSegments.length - 1] = pageTitle;
            return breadcrumbSegments.join(' > ');
        } else if (breadcrumbSegments.length === 1) {
            // Only one segment, just use the page title
            return pageTitle;
        } else {
            // No segments, return page title
            return pageTitle;
        }
    }

    search.addEventListener('input', show_results, true);

    function show_results(){
        const maxResult = {{ .Site.Params.flexsearch.maxResult | default 10}};
        const minlength = {{ .Site.Params.flexsearch.minQueryChar | default 0}};
        var searchQuery = sanitizeHTML(this.value);
        var results = index.search(searchQuery, {limit: maxResult, enrich: true});

        // flatten results since index.search() returns results for each indexed field
        const flatResults = new Map(); // keyed by href to dedupe results
        for (const result of results.flatMap(r => r.result)) {
        if (flatResults.has(result.doc.href)) continue;
        flatResults.set(result.doc.href, result.doc);
        }

        suggestions.innerHTML = "";
        suggestions.classList.remove('d-none');

        // inform user of search query minimum character requirement
        if (searchQuery.length < minlength) {
            const minCharMessage = document.createElement('div')
            minCharMessage.innerHTML = `Please type at least <strong>${minlength}</strong> characters`
            minCharMessage.classList.add("suggestion__no-results");
            suggestions.appendChild(minCharMessage);
            return;
        } else {
            // inform user that no results were found
            if (flatResults.size === 0 && searchQuery) {
                const noResultsMessage = document.createElement('div')
                noResultsMessage.innerHTML = {{ i18n "search_no_results" | default "No results for" }} + ` "<strong>${searchQuery}</strong>"`
                noResultsMessage.classList.add("suggestion__no-results");
                suggestions.appendChild(noResultsMessage);
                return;
            }
        }

        // construct a list of suggestions
        for(const [href, doc] of flatResults) {
            const entry = document.createElement('div');
            suggestions.appendChild(entry);

            const a = document.createElement('a');
            a.href = href;
            entry.appendChild(a);

            const title = document.createElement('span');
            // Generate breadcrumb from URL path
            const breadcrumb = generateBreadcrumb(href, doc.title);
            title.textContent = breadcrumb;
            title.classList.add("suggestion__title");
            a.appendChild(title);

            const description = document.createElement('span');
            description.textContent = doc.description;
            description.classList.add("suggestion__description");
            a.appendChild(description);

            suggestions.appendChild(entry);

            if(suggestions.childElementCount == maxResult) break;
        }
    }
    }());
</script>